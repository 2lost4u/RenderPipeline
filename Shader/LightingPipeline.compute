#version 440



// here the result is stored
layout (rgba8) writeonly uniform image2D destinationImage;

// inputs used for the computation
layout (rgba16f) readonly uniform image2D target0Image;
layout (rgba16f) readonly uniform image2D target1Image;
layout (rgba16f) readonly uniform image2D target2Image;
layout (rgba16f) readonly uniform image2D minMaxDepthImage;

layout (local_size_x = 8, local_size_y = 8) in;

uniform samplerCube fallbackCubemap;

#define MAX_VISIBLE_LIGHTS 64
#define MAX_LIGHTS_PER_PATCH 16


uniform mat4[MAX_VISIBLE_LIGHTS] lightData; 
uniform mat4[MAX_VISIBLE_LIGHTS] lightMatrices;
uniform float lightCount; 

uniform vec3 cameraPosition;


#include "Includes/Packing.include"
#include "Includes/Material.include"
#include "Includes/LightingModels.include"
#include "Includes/IntersectionTests.include"
#include "Includes/Lighting.include"
#include "Includes/PositionReconstruction.include"



shared Light visibleLights[MAX_LIGHTS_PER_PATCH];
shared int lightsSoFar = 0;


void main() {


    // Size of the real screen
    ivec2 realScreenSize = ivec2(1600, 928);

    // Size of the compute buffer. This might be bigger, because it always
    // has to be a multiple of vec2(local_size_x, local_size_y) 
    // and will get cropped later.
    vec2 computeScreenSize = vec2(1600, 928);

    // Position in compute space
    ivec2 computePos = ivec2(gl_GlobalInvocationID.xy);

    // Position in precomputed space
    ivec2 precomputePos = ivec2(gl_WorkGroupID.xy);

    // Position in screen space coordinates
    vec2  screenPos  = vec2(gl_GlobalInvocationID.xy) / computeScreenSize;

    // Border visualization
    float borderFactor = 0.0;
    if (gl_LocalInvocationID.x < 1 || gl_LocalInvocationID.y < 1) 
        borderFactor = 1.0;

    // Fetch data from targets
    vec4 target0Data = imageLoad(target0Image, computePos);
    vec4 target1Data = imageLoad(target1Image, computePos);
    vec4 target2Data = imageLoad(target2Image, computePos);

    // Fetch packed material data
    Material material = unpackMaterial(target0Data, target1Data, target2Data);

    // Fetch patch min / max pos from previous pass
    vec4 patchMinMaxDepth = imageLoad(minMaxDepthImage, precomputePos).rgba;
    float patchMinDepth    = unpackDepth(patchMinMaxDepth.xy);
    float patchMaxDepth    = unpackDepth(patchMinMaxDepth.zw);

    vec3 patchMinPosition = calculateSurfacePos(patchMinDepth, screenPos);
    vec3 patchMaxPosition = calculateSurfacePos(patchMaxDepth, screenPos);

    // Collect lights
    int cellIndex = int(gl_LocalInvocationIndex);

    barrier();


    if (cellIndex < min(MAX_VISIBLE_LIGHTS, lightCount) ) {

        mat4 currentLightData = lightData[cellIndex];
        mat4 currentLightMatrix = lightMatrices[cellIndex];

        // only if a light is contained
        if (currentLightData[0][0] > 0.0) {

            // convert to light structure
            Light current;
            current.type = int(currentLightData[0][0]);
            current.position = currentLightData[2].xyz;
            current.color = currentLightData[0].yzw;
            current.radius = 0.0;

            // add light only if visible for this patch
            if (isInLightBounds(current, currentLightData, patchMinPosition, patchMaxPosition)) {

                int arrayIndex = atomicAdd(lightsSoFar, 1);
                // int arrayIndex = 0;
                    
                // only add if there are not already too many lights per patch
                if (arrayIndex < MAX_LIGHTS_PER_PATCH) {
                    visibleLights[arrayIndex] = current;
                }
            }
        } 
    }

    memoryBarrier();
    barrier();

    vec3 lightingResult = vec3(0);


    // Now compute lighting, as we know now which lights are active
    // for this patch
    int localLightCount = min(MAX_LIGHTS_PER_PATCH, lightsSoFar);

    for (int i = 0; i < localLightCount; i++) {

        Light current = visibleLights[i];
        lightingResult += computeLighting(current, material);
        // lightingResult += current.color * 0.1;
    }


    vec4 result = vec4(lightingResult, 1.0);


    float intensityFactor = float(localLightCount) / float(MAX_LIGHTS_PER_PATCH);

    // if (borderFactor> 0.0) {
        // result.xyz = vec3(localLightCount > 0 ? 1.0 : 0.0);
    result.xyz += vec3(intensityFactor, 1.0 - intensityFactor, 0.0) * 0.3;
    // }    


    // Debugging modes
    // result.xyz = vec3(cubeIntersectsSphere(material.position, material.position, vec3(10, 10, 10), 19.0) ? 1.0 : 0.1);


    result.xyz = clamp(result.xyz, 0, 1);
    // result.xyz += vec3(1,1,0) * borderFactor * 0.09;


    imageStore(destinationImage, computePos, vec4(result) );


}