#version 440

// here the result is stored
layout (rgba8) writeonly uniform image2D destinationImage;

// inputs used for the computation
layout (rgba16f) readonly uniform image2D target0Image;
layout (rgba16f) readonly uniform image2D target1Image;
layout (rgba16f) readonly uniform image2D target2Image;
layout (rgba16f) readonly uniform image2D minPositionImage;
layout (rgba16f) readonly uniform image2D maxPositionImage;

layout (local_size_x = 32, local_size_y = 16) in;

uniform samplerCube fallbackCubemap;


#define MAX_VISIBLE_LIGHTS 64
#define MAX_LIGHTS_PER_PATCH 64

uniform mat4[MAX_VISIBLE_LIGHTS] lightData; 
uniform mat4[MAX_VISIBLE_LIGHTS] lightMatrices;
uniform float lightCount; 

uniform vec3 cameraPosition;



// Commonly used structs
struct Material {
    vec3 diffuse;
    vec3 position;
    vec3 normal;
    float specular;
    float smoothness;
    float gloss;
    float transluency;
    float roughness;
};

struct Light {
    int type;
    vec3 position;
    vec3 color;

    float radius;

};

shared Light visibleLights[MAX_LIGHTS_PER_PATCH];
shared int lightsSoFar = 0;

// Lighting variables
const float rho = 1.0;
const float sigma = 90.0;
const float PI = 3.14159265358979323846;
const float DIRECTIONAL_LIGHT_SIZE = 9999999999999.0;


// Functions


vec3 reconstructNormal(vec2 packedNormal) {
    return vec3(packedNormal.xy, 
        sqrt(1.0 - packedNormal.x*packedNormal.x - packedNormal.y*packedNormal.y));
}

float unpackPacked(float v) {
    return (v-0.5) * 4.0;
}

vec2 unpackVec2FromFloat(float data) {

    float component2 = unpackPacked(float(int(data)) / 255.0);
    float component1 = unpackPacked(fract(data));
    return vec2( 0 , component1 );
}


float squared(float v) { 
    return v * v; 
}

bool cubeIntersectSphere(vec3 aabbMin, vec3 aabbMax, vec3 sphereMid, float sphereRadius)
{
    float dist_squared = sphereRadius * sphereRadius;
    /* assume C1 and C2 are element-wise sorted, if not, do that now */
    if (sphereMid.x < aabbMin.x) dist_squared -= squared(sphereMid.x - aabbMin.x);
    else if (sphereMid.x > aabbMax.x) dist_squared -= squared(sphereMid.x - aabbMax.x);
    if (sphereMid.y < aabbMin.y) dist_squared -= squared(sphereMid.y - aabbMin.y);
    else if (sphereMid.y > aabbMax.y) dist_squared -= squared(sphereMid.y - aabbMax.y);
    if (sphereMid.z < aabbMin.z) dist_squared -= squared(sphereMid.z - aabbMin.z);
    else if (sphereMid.z > aabbMax.z) dist_squared -= squared(sphereMid.z - aabbMax.z);
    return dist_squared > 0;
}




bool isInLightBounds(inout Light light, mat4 rawData, vec3 aabbMin, vec3 aabbMax) {



    // Compute bounding sphere
    // This might not be perfect, but fast
    vec3 collideSphereMid = (aabbMin + aabbMax) / 2.0;
    float collideSphereRadius = distance(aabbMin, aabbMax) * 0.5;

    // PointLight
    if (light.type == 1) {

        // Distance to our mid
        float distanceToLight = distance(collideSphereMid, light.position);

        // Also fetch radius
        light.radius = rawData[2][3];

        if (light.radius > 100000.0) {
            light.radius = 999999999999.0;
        }

        // Rough Sphere collision
        if (distanceToLight < collideSphereRadius + light.radius) {

            // return true;

            // Exact collision testing
            if (cubeIntersectSphere(aabbMin, aabbMax, light.position, light.radius)) {
                return true;
            }

        }

    }


    return false;
}



float safeDot(vec3 a, vec3 b) {
    return max(0.0, dot(a, b));
}


vec3 specularBrdfFresnel(vec3 f0, float u)
{
    // from Schlick
    return f0 + (1-f0) * pow(1-u, 5);
}


float specularBrdfD(vec3 n, vec3 h, float roughness) {
    return (roughness * roughness) / (
        PI * pow(
            pow(dot(n, h), 2.0) *
            ( (roughness * roughness) - 1.0 ) + 1 , 2.0)
        );
}

float smoothnessToRoughness(float smoothness) {
    return clamp(pow(1.0 - smoothness * 0.7, 6.0), 0, 1);
}


float specularGGetK(float a) {
    return pow(0.8 + 0.5 * a, 2.0) * 0.5;
}

float specularBrdfGSub(vec3 v, vec3 n, float roughness) {
    float nDotV = safeDot(n, v);
    return nDotV / ( nDotV * (1.0-roughness) + roughness );
}

float specularBrdfG(vec3 l, vec3 v, vec3 h, vec3 n, float roughness) {
    float k = specularGGetK(roughness);
    return specularBrdfGSub(l, n, k) * specularBrdfGSub(v, n, k);
}




vec3 diffuseBrdfOrenNayar( vec3 L, vec3 V, vec3 N )
{
    float VdotN = dot(V,N);
    float LdotN = dot(L,N);
    float theta_r = acos (VdotN);
    float sigma2 = pow(sigma*PI/180,2);

    float cos_phi_diff = dot( normalize(V-N*(VdotN)), normalize(L - N*(LdotN)) );
    float theta_i = acos (LdotN);
    float alpha = max (theta_i, theta_r);
    float beta = min (theta_i, theta_r);
    if (alpha > PI/2) return vec3(0);

    float C1 = 1 - 0.5 * sigma2 / (sigma2 + 0.33);
    float C2 = 0.45 * sigma2 / (sigma2 + 0.09);
    if (cos_phi_diff >= 0) C2 *= sin(alpha);
    else C2 *= (sin(alpha) - pow(2*beta/PI,3));
    float C3 = 0.125 * sigma2 / (sigma2+0.09) * pow ((4*alpha*beta)/(PI*PI),2);
    float L1 = rho/PI * (C1 + cos_phi_diff * C2 * tan(beta) + (1 - abs(cos_phi_diff)) * C3 * tan((alpha+beta)/2));
    float L2 = 0.17 * rho*rho / PI * sigma2/(sigma2+0.13) * (1 - cos_phi_diff*(4*beta*beta)/(PI*PI));
    return vec3(L1 + L2);
}







vec3 computeLighting(Light light, Material material) {

    // Point light
    if (light.type == 1) {

        // Compute distance to light
        float distanceToLight = distance(material.position, light.position);    

        // Compute attenuation
        float attenuation = pow(1.0 + (distanceToLight / light.radius) , -2.0) * 1.0;
        float normfac = pow(1.0 + (1.0/light.radius) , 2.0);
        attenuation *= normfac;

        // Cut light transition starting at 80%. Otherwise it's exponential and never gets really 0
        float cutoff = light.radius * 0.8;
        float cutoffFactor = 0.25;
        attenuation *= 1.0 - smoothstep(0.0, 1.0, ((distanceToLight / cutoff) - 1.0) * 4.0 );   
        attenuation = max(0.0, attenuation);

        // Compute vectors
        vec3 l = normalize(light.position - material.position);
        vec3 v = normalize(cameraPosition - material.position);
        vec3 n = normalize(material.normal);
        vec3 h = normalize(l + v);

        // Compute reflection
        vec3 reflectedDir = reflect(v, n);
        float cubemapResolutionParameter = material.gloss;
        vec3 reflection1 = textureLod(fallbackCubemap, reflectedDir.xzy, cubemapResolutionParameter * 10.0).rgb;
        vec3 reflection2 = textureLod(fallbackCubemap, reflectedDir.xzy, cubemapResolutionParameter * 10.0 - 1.0).rgb;
        vec3 reflectedColor = reflection1*0.5 + reflection2*0.5;

        // Ambient is not used yet
        float ambient = 0.0;

        // Compute specular BRDF
        float specG = clamp(specularBrdfG(l, v, h, n, material.roughness), 0, 1);
        vec3  specF = clamp(specularBrdfFresnel(vec3(material.specular), safeDot(v, h)  ) , 0, 1);

        // D is not clamped, highlights can get very bright
        float specD = specularBrdfD(n, h, material.roughness); 

        // Compute diffuse BRDF
        vec3 diffuseBrdf = diffuseBrdfOrenNayar(l, v, n) * safeDot(n, l);

        // Combine specular
        vec3 specularTerm = (specF * specG * specD) * max(0.0, 4.0 * dot(n, l) * dot(n, v));

        // Compute total contributions
        vec3 refractiveContribution = (reflectedColor) * material.smoothness * specF * attenuation;
        vec3 diffuseContribution = material.diffuse * diffuseBrdf * attenuation * light.color + ambient * attenuation;
        vec3 specularContribution = specularTerm * attenuation * light.color; 

        vec3 combinedContribution = refractiveContribution + diffuseContribution + specularContribution;


        // For debugging
        // return vec3(clamp(attenuation * specularTerm * light.color * 15.0, 0, 1));
        return vec3(clamp(combinedContribution, 0, 1));

    }

    return light.color;

}



void main() {


    // Size of the real screen
    ivec2 realScreenSize = ivec2(1600, 928);

    // Size of a patch
    ivec2 patchSize = ivec2(32, 16);

    // Size of the compute buffer. This might be bigger, because it always
    // has to be a multiple of vec2(local_size_x, local_size_y) 
    // and will get cropped later.
    vec2 computeScreenSize = vec2(1600, 928);

    // Position in compute space
    ivec2 computePos = ivec2(gl_GlobalInvocationID.xy);

    // Position in precomputed space
    ivec2 precomputePos = ivec2(gl_WorkGroupID.xy);

    // Position in screen space coordinates
    vec2  screenPos  = vec2(gl_GlobalInvocationID.xy) / computeScreenSize;

    // Border visualization
    float borderFactor = 0.0;
    if (gl_LocalInvocationID.x < 1 || gl_LocalInvocationID.y < 1) 
        borderFactor = 1.0;

    // Fetch data from targets
    vec4 target0Data = imageLoad(target0Image, computePos);
    vec4 target1Data = imageLoad(target1Image, computePos);
    vec4 target2Data = imageLoad(target2Image, computePos);

    // Fetch packed material data
    Material material;
    material.diffuse        = target0Data.xyz;
    material.position       = target2Data.xyz;
    material.specular       = target0Data.a;
    material.normal         = target1Data.xyz;
    material.gloss          = target1Data.w;
    material.transluency    = 0.0;
    material.position       = target2Data.xyz;
    material.smoothness     = target2Data.a;
    material.roughness      = smoothnessToRoughness(material.smoothness);

    vec4 result = vec4(material.position, 1);
    result.a = 1.0;

    // Fetch patch min / max pos from previous pass
    vec3 patchMinPosition = imageLoad(minPositionImage, precomputePos).xyz;
    vec3 patchMaxPosition = imageLoad(maxPositionImage, precomputePos).xyz;

    float patchDistance = distance(patchMinPosition, patchMaxPosition);

    // If they are very far away, we probably sampled too far
    // This is solved by taking the max position nearer to the min position
    // if (patchDistance > 50.0) {

    //     vec3 extrudeVec = normalize(patchMinPosition - cameraPosition);
    //     patchMaxPosition = patchMinPosition + extrudeVec * 50.0;

    // }


    // Collect lights

    int cellIndex = int(gl_LocalInvocationIndex);

    // memoryBarrier();
    barrier();


    if (cellIndex < min(MAX_VISIBLE_LIGHTS, lightCount) ) {


        mat4 currentLightData = lightData[cellIndex];
        mat4 currentLightMatrix = lightMatrices[cellIndex];

        // only if a light is contained
        if (currentLightData[0][0] > 0.0) {

            // convert to light structure
            Light current;
            current.type = int(currentLightData[0][0]);
            current.position = currentLightData[2].xyz;
            current.color = currentLightData[0].yzw;
            current.radius = 0.0;



            // add light only if visible for this patch
            if (isInLightBounds(current, currentLightData, patchMinPosition, patchMaxPosition)) {

                int arrayIndex = atomicAdd(lightsSoFar, 1);
                    
                // only add if there are not already too many lights per patch
                if (arrayIndex < MAX_LIGHTS_PER_PATCH) {
                    visibleLights[arrayIndex] = current;
                }

            }


        } 
    }

    memoryBarrier();
    barrier();

    vec3 lightingResult = vec3(0);


    // Now compute lighting, as we know now which lights are active
    // for this patch
    int localLightCount = min(MAX_LIGHTS_PER_PATCH, lightsSoFar);

    for (int i = 0; i < localLightCount; i++) {

        Light current = visibleLights[i];
        lightingResult += computeLighting(current, material);
    }


    result.xyz = vec3(lightingResult);


    float intensityFactor = float(localLightCount) / float(MAX_LIGHTS_PER_PATCH);

    if (borderFactor> 0.0) {
        // result.xyz = vec3(localLightCount > 0 ? 1.0 : 0.0);
        // result.xyz = vec3(intensityFactor, 1.0 - intensityFactor, 0.0);
    }    

    // result.xyz = vec3(material.normal);

    result.xyz = clamp(result.xyz, 0, 1);
    // result.xyz += vec3(1,1,0) * borderFactor * 0.09;


    imageStore(destinationImage, computePos, vec4(result) );


}