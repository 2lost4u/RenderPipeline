#version 440


in vec3 normalWorldSpace;
in vec3 positionWorldSpace;
in vec2 texcoord;

uniform vec3 cameraPosition;

uniform sampler2D p3d_Texture0;
uniform sampler2D p3d_Texture1;
uniform sampler2D p3d_Texture2;
uniform samplerCube cubemap;

// uniform float osg_FrameTime;


// BRDF

const float rho = 1.0;
const float sigma = 90.0;
const float PI = 3.14159265358979323846;
const float DIRECTIONAL_LIGHT_SIZE = 9999999999999.0;

const mat3 RGBtoYCBCR = mat3(
        0.299, -0.168736, 0.5,
        0.587, -0.331264, -0.418688,
        0.114, -0.5,      -0.081312
    );


float safeDot(vec3 a, vec3 b) {
    return max(0.0, dot(a, b));
}


vec3 OrenNayar( vec3 L, vec3 V, vec3 N )
{
    float VdotN = dot(V,N);
    float LdotN = dot(L,N);
    float theta_r = acos (VdotN);
    float sigma2 = pow(sigma*PI/180,2);

    float cos_phi_diff = dot( normalize(V-N*(VdotN)), normalize(L - N*(LdotN)) );
    float theta_i = acos (LdotN);
    float alpha = max (theta_i, theta_r);
    float beta = min (theta_i, theta_r);
    if (alpha > PI/2) return vec3(0);

    float C1 = 1 - 0.5 * sigma2 / (sigma2 + 0.33);
    float C2 = 0.45 * sigma2 / (sigma2 + 0.09);
    if (cos_phi_diff >= 0) C2 *= sin(alpha);
    else C2 *= (sin(alpha) - pow(2*beta/PI,3));
    float C3 = 0.125 * sigma2 / (sigma2+0.09) * pow ((4*alpha*beta)/(PI*PI),2);
    float L1 = rho/PI * (C1 + cos_phi_diff * C2 * tan(beta) + (1 - abs(cos_phi_diff)) * C3 * tan((alpha+beta)/2));
    float L2 = 0.17 * rho*rho / PI * sigma2/(sigma2+0.13) * (1 - cos_phi_diff*(4*beta*beta)/(PI*PI));
    return vec3(L1 + L2);
}


float Beckmann(float m, float t)
{
    float M = m*m;
    float T = t*t;
    return exp((T-1)/(M*T)) / (M*T*T);
}

vec3 Fresnel(vec3 f0, float u)
{
    // from Schlick
    return f0 + (1-f0) * pow(1-u, 5);
}


float getD(vec3 n, vec3 h, float roughness) {
    return (roughness * roughness) / (
        PI * pow(
            pow(dot(n, h), 2.0) *
            ( (roughness * roughness) - 1.0 ) + 1 , 2.0)
        );
}

float smoothnessToRoughness(float smoothness) {
    return clamp(pow(1.0 - smoothness * 0.7, 6.0), 0, 1);
}


float getK(float a) {
    return pow(0.8 + 0.5 * a, 2.0) * 0.5;
}

float G1(vec3 v, vec3 n, float roughness) {
    float nDotV = safeDot(n, v);
    return nDotV / ( nDotV * (1.0-roughness) + roughness );
}

float getG(vec3 l, vec3 v, vec3 h, vec3 n, float roughness) {
    float k = getK(roughness);
    return G1(l, n, k) * G1(v, n, k);
}


// uniform float smoothness;
// uniform float gloss;



vec2 convertToPackedYCbCr(vec3 rgb) {
    vec3 ycbcr = RGBtoYCBCR * rgb;
    return vec2(ycbcr.r, ycbcr.g + ycbcr.b*0.0);
    // return vec2(rgb.xy);

}


void main() {


    vec3 diffuse = texture(p3d_Texture0, texcoord).rgb;
    vec3 normals = texture(p3d_Texture1, texcoord).rgb;
    float specular = texture(p3d_Texture2, texcoord).r;

    // vec3 lightPos = vec3(sin(osg_FrameTime) * 10.0 , cos(osg_FrameTime) * 10.0, 22.0);
    // vec3 lightPos = vec3(9.0, 9.0, 9.0) * 10000.0;

    // vec3 l = normalize(lightPos - positionWorldSpace); // lightVector
    // vec3 v = normalize(cameraPosition - positionWorldSpace); // viewVector
    vec3 n = normalWorldSpace;  // normal
    // vec3 h = normalize(l + v);

    n += (normals-0.5) * 0.5; // detail normal sampling
    n = normalize(n);


    // Per Material
    // vec3 specularColor = vec3(0.0);
    vec3 specularColor = vec3(1.0, 0.78, 0.29);
    // specularColor = vec3(0.05, 0.05 ,0.05);
    specularColor = vec3(0.1);

    vec3 diffuseColor  = vec3(0);
    float ambient = 0.00;
    float specularPower = 1.0;
    float gloss = 0.8;
    float smoothness = 0.7;
    float transluency = 0.5;


    // specularColor *= 1.0 - step(positionWorldSpace.z, 0.01);

    // Ensure no invalid values are passed
    float realSmoothness = clamp(smoothness, 0.001, 1.0);
    float realGloss      = clamp(1.0 - gloss, 0.001, 1.0);

    // specularPower = gloss * 2.0 + .1;


    // realSmoothness = 0.5;
    // realGloss = 0.4;

    // We're specifying smoothnes, but for the lightning terms we need roughness
    float roughness = smoothnessToRoughness(realSmoothness);


    diffuse = vec3(0.6,0.5, 0.7);


    // gl_FragData[0] = vec4(convertToPackedYCbCr(diffuse), specular, smoothness);
    // gl_FragData[1] = vec4(n.xy, gloss, transluency);
    // gl_FragData[2] = vec4(positionWorldSpace, specularPower);


    gl_FragData[0] = vec4(1.0, 1.0, 1.0, 0.0);
    gl_FragData[1] = vec4(1000.0, 0.0, 0.0, 1.0);
    gl_FragData[2] = vec4(0.0, 0.0, 0.0, 1.0);
    // gl_FragData[3] = vec4(specD, specF.x, specG, 1.0);



    // float cubemapResolutionParameter = (1.0 - realSmoothness);
    // cubemapResolutionParameter = realGloss;


    // // Reflections
    // vec3 reflectedDir = reflect(v, n);
    

    // vec3 reflection1 = textureLod(cubemap, reflectedDir.xzy, cubemapResolutionParameter * 10.0).rgb;
    // vec3 reflection2 = textureLod(cubemap, reflectedDir.xzy, cubemapResolutionParameter * 10.0 - 1.0).rgb;

    // // vec3 reflectedColor = reflection1*0.5 + reflection2*0.5;
    // vec3 reflectedColor = reflection1;




    // // Compute specular BRDF
    // float specG = clamp(getG(l, v, h, n, roughness), 0, 1);
    // vec3  specF = clamp(Fresnel(specularColor, safeDot(v, h)  ) , 0, 1);
    // float specD = getD(n, h, roughness); // D is not clamped, highlights can get very bright

    // // Combine
    // vec3 specularTerm = (specF * specG * specD) * max(0.0, 4.0 * dot(n, l) * dot(n, v));

    // // Compute diffuse BRDF
    // vec3 diffBrdf = OrenNayar(l, v, n) * safeDot(n, l);

    // // Compute attenuation    
    // float distanceToLight = distance(lightPos, positionWorldSpace);
    // float lightSize = DIRECTIONAL_LIGHT_SIZE;
    // // float lightSize = 30.0;
    // float attenuation = 0.0;


    //     // crytek's approach
    //     attenuation = pow(1.0 + (distanceToLight / lightSize) , -2.0); 
    //     float normfac = pow(1.0 + (1.0/lightSize) , 2.0);
    //     attenuation *= normfac;

    //     // default approach (I like this more tbh)
    //     // attenuation = pow(1.0 - (distanceToLight / lightSize) , 2.0); 


    // // Cut light transition starting at 80%. Otherwise it's exponential and never gets really 0
    // float cutoff = lightSize * 0.8;
    // float cutoffFactor = 0.25;
    // attenuation *= 1.0 - smoothstep(0.0, 1.0, ((distanceToLight / cutoff) - 1.0) * 4.0 );


    // // Compute contributions
    // vec3 refractiveContribution = (reflectedColor) * realSmoothness * specF * specularPower * attenuation;
    // vec3 diffuseContribution = diffuseColor * diffBrdf * attenuation + ambient * attenuation;
    // vec3 specularContribution = specularTerm * attenuation * specularPower; 


    // Mix contributions
    // gl_FragData[0] = vec4(diffuseContribution + specularContribution + refractiveContribution, 1.0);



    // gl_FragColor.xyz = vec3( specF * 0.1 );

    // Gamma correct
    // actually it's pow(color, 1.0 / 2.2), but this simplifies it to
    // pow(color, 1.0 / 2.0) which is sqrt(color)

    // gl_FragColor.xyz = RGBtoYCBCR * vec3(0.0, 1.0, 1.0);
    // gl_FragColor.xyz = vec3( gl_FragColor.x);

    // gl_FragColor.xyz = sqrt(gl_FragColor.xyz);
}
