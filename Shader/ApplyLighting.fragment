#version 440

// TODO: Make some benchmarks to see wheter unrolling
// is faster or slower ..

// EDIT: As of now, not unrolling is faster?
// #pragma optionNV (unroll all)

#include "Includes/Configuration.include"
#include "Includes/Light.include"
#include "Includes/Material.include"
#include "Includes/ShadowSource.include"
#include "Includes/ColorCorrection.include"

uniform sampler2D data0;
uniform sampler2D data1;
uniform sampler2D data2;

// uniform sampler2D lightsPerTile;
layout (r32i) readonly uniform iimage2D lightsPerTile;

<<<<<<< HEAD
=======

uniform sampler2D sampleTex;

>>>>>>> origin/master
uniform Light lights[MAX_VISIBLE_LIGHTS]; 
uniform ShadowSource shadowSources[SHADOW_MAX_TOTAL_MAPS]; 
in vec2 texcoord;


// Has to be after the uniformsr
#include "Includes/Lighting.include"

void main() {

    #if 1
    // Compute texcoords
    ivec2 screenSize = textureSize(data0, 0);
    ivec2 screenCoord = ivec2(texcoord * vec2(screenSize)); 
    // ivec2 precomputeSize = textureSize(lightsPerTile, 0) / ivec2(8);
    ivec2 precomputeSize = imageSize(lightsPerTile) / ivec2(8);
    // ivec2 precomputeCoord = ivec2(texcoord * precomputeSize) * ivec2(8);
    ivec2 precomputeCoord = ivec2(texcoord * precomputeSize) * ivec2(8);

    // Extract material data
    vec4 target0data = texelFetch(data0, screenCoord, 0);
    vec4 target1data = texelFetch(data1, screenCoord, 0);
    vec4 target2data = texelFetch(data2, screenCoord, 0);

    BaseMaterial material = unpackBaseMaterial(target0data, target1data, target2data);

    // Fetch number of lights for this tile
    // int tileLightCount = int( texelFetch(lightsPerTile, precomputeCoord, 0).r * float(MAX_LIGHTS_PER_PATCH) );
    int tileLightCount = imageLoad(lightsPerTile, precomputeCoord).r;
    int numActiveLights = min(tileLightCount, MAX_LIGHTS_PER_PATCH);

    // numActiveLights = 20;

    vec3 result = vec3(0.0);

    // Compute each light which affects this tile
    for (int i = 0; i < numActiveLights; i++) {


            // Light index is offsetted by 1, because at position 0 
            // the number of lights is stored
            int index = i+1;

            // Compute offset by index
            ivec2 offset = ivec2(index % 8, index / 8);

            // Extract light id from texture, and fetch data for that light
            int lightId = imageLoad(lightsPerTile, precomputeCoord + offset).r;


            // Convert to light struct
            Light currentLight = lights[lightId];
            result += computeLighting(currentLight, material);

    }


    // if ( distance(material., vec3(1,1,0) ) < 0.001 ) {
    //     result = vec3(1,1,0);
    // }



    float lightsVisibleFloat = float(numActiveLights) / float(MAX_LIGHTS_PER_PATCH);
    vec3 lightCountIndicator = vec3(lightsVisibleFloat, 1.0 - lightsVisibleFloat , 0);

    float borderFactor = 0.0;
    if (screenCoord.x % LIGHTING_COMPUTE_PATCH_SIZE_X == 0 || screenCoord.y % LIGHTING_COMPUTE_PATCH_SIZE_Y == 0) {
        borderFactor = 1.0;
    }


    // HDR Mapping
    result.xyz = 1.0f - exp(-1.0 * result.xyz);
    result.xyz = saturate(result.xyz);

    // Tone Mapping
    result.xyz = sqrt(result.xyz);
    vec3 colorCorrected = convertColorSpace(result.xyz);
    result.xyz = mix( colorCorrected , result.xyz, 0.0);



    // result.xyz = texture(sampleTex, vec2(texcoord.x, 1.0 - texcoord.y)).rgb;
    // result.xyz = texture(sampleTex, texcoord).rgb;

    // result.xyz = colorCorrected;

    // result.xyz = step(-material.position.z, 0.01) * vec3(1);
    // result.xyz = step(0.0001, material.position.z) * vec3(1.0);
    
    #else

        vec3 result = vec3(1);
    #endif

    gl_FragColor = vec4(result.xyz, 1);
}