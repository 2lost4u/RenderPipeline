#version 440

#extension GL_ARB_shader_image_load_store : enable

// TODO: Make some benchmarks to see wheter unrolling
// is faster or slower ..

// EDIT: As of now, not unrolling is faster?
// #pragma optionNV (unroll all)

#include "Includes/Configuration.include"
#include "Includes/Light.include"
#include "Includes/Material.include"
#include "Includes/ShadowSource.include"
#include "Includes/ColorCorrection.include"

uniform sampler2D data0;
uniform sampler2D data1;
uniform sampler2D data2;




// uniform sampler2D lightsPerTile;
layout (r32i) readonly uniform iimage2D lightsPerTile;
layout (rgba16f) uniform image2D destination;


uniform Light lights[MAX_VISIBLE_LIGHTS]; 
uniform ShadowSource shadowSources[SHADOW_MAX_TOTAL_MAPS]; 
in vec2 texcoord;

uniform float temporalProjXOffs;

uniform sampler2D sampleTex;

uniform mat4 lastMVP;



// Has to be after the uniforms
#include "Includes/Lighting.include"

void main() {



    #if 1
    


    // Compute texcoords
    ivec2 screenSize = textureSize(data0, 0);
    
    // ivec2 screenCoord = ivec2(texcoord * vec2(screenSize.x)) + ivec2(0,0); 
    ivec2 screenCoord = ivec2(texcoord * vec2(screenSize.x+1, screenSize.y)) - ivec2(temporalProjXOffs,0); 
    // ivec2 screenCoord = ivec2(texcoord * vec2(screenSize.x, screenSize.y)); 

    // ivec2 screenCoord = ivec2(texcoord * vec2(screenSize.x)); 
    // ivec2 precomputeSize = textureSize(lightsPerTile, 0) / ivec2(8);
    ivec2 precomputeSize = imageSize(lightsPerTile) / ivec2(8);
    // ivec2 precomputeCoord = ivec2(texcoord * precomputeSize) * ivec2(8);
    ivec2 precomputeCoord = ivec2(texcoord * precomputeSize) * ivec2(8);

    // Extract material data
    vec4 target0data = texelFetch(data0, screenCoord, 0);
    vec4 target1data = texelFetch(data1, screenCoord, 0);
    vec4 target2data = texelFetch(data2, screenCoord, 0);

    BaseMaterial material = unpackBaseMaterial(target0data, target1data, target2data);

    // vec4 projectedBack = lastMVP * vec4(material.position, 1);
    // projectedBack.xyz /= projectedBack.w;
    // projectedBack.xy = projectedBack.xy * 0.5 + 0.5;

    // ivec2 lastScreenCoord = ivec2(projectedBack.xy * vec2(screenSize.x, screenSize.y)); 

    // vec4 oldPixelValue = imageLoad(destination, lastScreenCoord).rgba;

    // Fetch number of lights for this tile
    // int tileLightCount = int( texelFetch(lightsPerTile, precomputeCoord, 0).r * float(MAX_LIGHTS_PER_PATCH) );

    int countPointLight = imageLoad(lightsPerTile, precomputeCoord + ivec2(0,0)).r;
    int countPointLightShadow = imageLoad(lightsPerTile, precomputeCoord + ivec2(1,0)).r;

    vec3 result = vec3(0);

    // Compute point lights
    ivec2 baseOffset = precomputeCoord + ivec2(0,1);
    ivec2 currentOffset = ivec2(0);
    int currentLightId = 0;
    Light currentLight;

    for (int i = 0; i < countPointLight; i++) {
        currentOffset = ivec2(i%8, i/8);
        currentLightId = imageLoad(lightsPerTile, baseOffset + currentOffset).r;
        currentLight = lights[currentLightId];

        result += applyPointLight(currentLight, material);
    }

    // Compute shadow point lights
    baseOffset = precomputeCoord + ivec2(0,3);
    for (int i = 0; i < countPointLightShadow; i++) {
        currentOffset = ivec2(i%8, i/8);
        currentLightId = imageLoad(lightsPerTile, baseOffset + currentOffset).r;
        currentLight = lights[currentLightId];

        result += applyPointLightWithShadow(currentLight, material);
    }



    // HDR Mapping
    result.xyz = 1.0f - exp(-1.0 * result.xyz);
    result.xyz = saturate(result.xyz);

    // Tone Mapping
    result.xyz = sqrt(result.xyz);
    vec3 colorCorrected = convertColorSpace(result.xyz);
    result.xyz = mix( colorCorrected , result.xyz, 0.3);

    result.xyz = saturate(result);
    // }

    // if (projectedBack.x >= 0.0 && projectedBack.x < 1.0 && projectedBack.y > 0.0 && projectedBack.y < 1.0) {
    //     result.xyz = mix(result.xyz, oldPixelValue.xyz, 0.3);
    // }


    // result.xyz = vec3(projectedBack.xy,0 );

    imageStore(destination, screenCoord, vec4(result.xyz, 1) );

    #else

        vec3 result = vec3(1);
    #endif

    gl_FragColor = vec4(result.xyz, 1);
}