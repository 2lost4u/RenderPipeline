#version 400
// #pragma optionNV (unroll all)

in vec2 texcoord;

uniform sampler2D color;
uniform sampler2D aux0;
uniform sampler2D aux1;
// uniform sampler2D depth;
// uniform vec4 bufferSize;


// vec3 getSampleAt(vec2 txc, int mipmap) {
//     // mipmap = 2;
//     vec2 subPxOffset = vec2(0, 0);
//     vec3 sample1 = textureLod(color, txc + subPxOffset, mipmap).rgb;
//     vec3 sample2 = textureLod(color, txc + subPxOffset, mipmap - 1).rgb;
//     return sample1 * 0.5 + sample2 * 0.5;
// }

void main() {

    // float weights[9] = float[9](1, 8, 28, 56, 70, 56, 28, 8, 1);
    // float sampleOffsets[9] = float[9]( -4, -3, -2 , -1, 0, 1, 2, 3, 4); 
    // float totalFactor = 256 * 256;

    // float depthSample = pow(texture(depth, texcoord).x, 1.0);

    // float blurFactor = max(0.0, (depthSample) - 0.6) * 2.0;

    // vec2 offsetFactor = bufferSize.xy * 7.0 * blurFactor;

    // int mip = int(blurFactor * 4.0);

    // vec3 result = vec3(0);
    // float weightsRespected = 0.0;

    // for (int x = 0; x < 9; x++) {
    //     for (int y = 0; y < 9; y++) {
    //         float weight = weights[x] * weights[y] / totalFactor;

    //         vec2 offset = vec2(sampleOffsets[x], sampleOffsets[y]) * offsetFactor;
    //         float depthAt = pow(texture(depth, texcoord + offset).x, 1.0);
    //         float blurFactorAt =  max(0.0, (depthAt) - 0.6) * 2.0;

    //         if (blurFactorAt >= blurFactor - 0.8) {
              
    //             vec3 sampled = getSampleAt(texcoord + offset, mip);
    //             result += sampled * weight;
    //             weightsRespected += weight;
    //         }
    //     }
    // }


    // result /= weightsRespected;

    vec3 result = texture(aux1, texcoord).rgb;
    gl_FragColor = vec4(result.rgb, 1.0);

}