
#include "Includes/Light.include"
#include "Includes/LightingModels.include"
#include "Includes/Material.include"
#include "Includes/ParabolicTransform.include"
#include "Includes/ShadowSource.include"

uniform vec3 cameraPosition;
uniform samplerCube fallbackCubemap;

const mat4 shadowBiasMatrix = mat4(
    0.5, 0.0, 0.0, 0.0,
    0.0, 0.5, 0.0, 0.0,
    0.0, 0.0, 0.5, 0.0,
    0.5, 0.5, 0.5, 1.0
);

uniform sampler2D shadowAtlas;


vec2 poissonDisk16[16] = vec2[](
    vec2(-0.7465202f, 0.4490219f),
    vec2(-0.6181046f, -0.07440206f),
    vec2(-0.1727871f, 0.003316618f),
    vec2(-0.05351699f, 0.5800206f),
    vec2(-0.4816332f, 0.7933055f),
    vec2(0.3972999f, 0.5579593f),
    vec2(0.4309787f, 0.08007714f),
    vec2(0.2419288f, -0.3548587f),
    vec2(0.5491309f, -0.6481215f),
    vec2(0.8807998f, 0.05989922f),
    vec2(0.8262667f, 0.4751753f),
    vec2(-0.3848403f, -0.5126396f),
    vec2(0.1026901f, -0.7473215f),
    vec2(-0.8397139f, -0.4312865f),
    vec2(0.145882f, 0.9274838f),
    vec2(0.88617f, -0.3436382f)
);




vec2 convertAtlasCoord(vec2 rawCoord, ShadowSource source) {

    float factor = float(source.resolution) / SHADOW_MAP_ATLAS_SIZE;
    float factorBy1 = 0.0005;
    return ( clamp(rawCoord, factorBy1, 1.0 - factorBy1) * factor + source.atlasPos);
}

vec3 computeLighting(Light light, Material material) {

    // Point light
    if (light.lightType == 1) {  

        // Compute distance to light
        float distanceToLight = distance(material.position, light.position);    

        // Compute attenuation
        float attenuation = pow(1.0 + (distanceToLight / light.radius) , -2.0) * 1.0;
        float normfac = pow(1.0 + (1.0/light.radius) , 2.0);
        attenuation *= normfac;

        // Cut light transition starting at 80%. Otherwise it's exponential and never gets really 0
        float cutoff = light.radius * 0.8;
        float cutoffFactor = 0.25;
        attenuation *= 1.0 - smoothstep(0.0, 1.0, ((distanceToLight / cutoff) - 1.0) * 4.0 );   
        attenuation = max(0.0, attenuation);

        #if 1
        // Compute vectors
        vec3 l = normalize(light.position - material.position);
        vec3 v = normalize(cameraPosition - material.position);
        vec3 n = normalize(material.normal);
        vec3 h = normalize(l + v);

        // Compute reflection
        vec3 reflectedDir = reflect(v, n);
        float cubemapResolutionParameter = 1.0 - material.gloss;
        vec3 reflection1 = textureLod(fallbackCubemap, reflectedDir.xzy, cubemapResolutionParameter * 10.0).rgb;
        vec3 reflection2 = textureLod(fallbackCubemap, reflectedDir.xzy, cubemapResolutionParameter * 10.0 - 1.0).rgb;
        vec3 reflectedColor = reflection1*0.5 + reflection2*0.5;
        // vec3 reflectedColor = vec3(1.0);

        // Ambient is not used yet
        float ambient = 0.0;

        // Compute specular BRDF
        float specG = clamp(specularBrdfG(l, v, h, n, material.roughness), 0, 1);
        vec3  specF = clamp(specularBrdfFresnel(vec3(material.specular), safeDot(v, h)  ) , 0, 1);

        // D is not clamped, highlights can get very bright
        float specD = specularBrdfD(n, h, material.roughness); 

        // Compute diffuse BRDF
        // vec3 diffuseBrdf = diffuseBrdfOrenNayar(l, v, n) * safeDot(n, l);
        vec3 diffuseBrdf = vec3(diffuseBrdfSimpleOrenNayar(l, v, n, 1.5));

        // Combine specular
        vec3 specularTerm = (specF * specG * specD) * max(0.0, 4.0 * dot(n, l) * dot(n, v));

        // Compute total contributions
        vec3 refractiveContribution = (reflectedColor) * material.smoothness * specF * attenuation * light.color;
        vec3 diffuseContribution = material.diffuse * diffuseBrdf * attenuation * light.color + ambient * attenuation;
        vec3 specularContribution = specularTerm * attenuation * light.color; 


        vec3 combinedContribution = refractiveContribution + diffuseContribution + specularContribution;

        // combinedContribution = dif;


        #endif 

        // Compute shadows

        float shadowFactor = 0.0;

        #if 0
        vec3 lightFactor = vec3(0);

        for (int shadowIndex = 0; shadowIndex < 6; shadowIndex ++) {

            int shadowSourceIndex = light.sourceIndexes[shadowIndex];

            if (shadowSourceIndex >= 0) {

                // shadowFactor -= 0.2;
                ShadowSource currentSource = shadowSources[shadowSourceIndex]; 

                vec4 projected = currentSource.mvp * vec4(material.position, 1);

                projected = transformParabol(projected, currentSource.nearPlane, currentSource.farPlane);
                projected = shadowBiasMatrix * projected;

                vec3 projCoord = projected.xyz / projected.w;

                bool shadowed = projCoord.y > 0.0 && projCoord.x >= 0.0 
                                && projCoord.x < 1.0 && projCoord.y < 1.0 &&
                                projected.w > currentSource.nearPlane && projected.w <= currentSource.farPlane;

                if (shadowed) {

                    float shadowInfluence = 0.0;

                    for (int i = 0; i< 16; i++) {
                        // int i = 0;
                        vec2 offset = poissonDisk16[i] / 500.0;
                        // vec2 offset = vec2(0);
                        vec2 rawSampled = texture(shadowAtlas, convertAtlasCoord(projCoord.xy + offset, currentSource) ).rg;
                        float sampled = unpackDepth(rawSampled);
                        shadowInfluence += (sampled > projCoord.z - 0.003)  ? 0.0 : 1.0 / 16.0; 

                    }

                    if (shadowInfluence > shadowFactor) {
                        shadowFactor = shadowInfluence;
                        float ff = float(shadowIndex) / 1.0;
                        lightFactor = vec3(ff, 1.0 - ff, 0);                        
                    }

                    // shadowFactor = rawSampled.x * 100.0;

                } 

                // shadowFactor = projCoord.y;
            }

        }
        // combinedContribution = vec3(1.0 - shadowFactor) * attenuation;

        combinedContribution *=1.0 - shadowFactor;

        #endif
        
        // combinedContribution = vec3(shadowFactorr) + material.normal*0.0;

        // combinedContribution.xyz = material.position;

        // combinedContribution = vec3(1.0 - shadowFactor) * attenuation;
        // combinedContribution = lightFactor * attenuation;
        
        // combinedContribution = attenuation * light.color;

        // return vec3(clamp(combinedContribution.xy, 0, 1));
        return combinedContribution.xyz;

    }

    return light.color;

}