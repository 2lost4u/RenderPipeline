#pragma once

#pragma include "Includes/Configuration.include"
#pragma include "Includes/Structures/Material.struct"


uniform samplerCube fallbackCubemap;
uniform samplerCube scatteringCubemap;

uniform float fallbackCubemapMipmaps;



vec3 transformCubemapCoordinates(vec3 coord) {
    return normalize(coord.xzy * vec3(1,-1,1));
}



float computeMipmapFromRoughness(float roughness) {
    // return 1;
    // return max(0.0, fallbackCubemapMipmaps + (log((roughness+0.21)/log(20))+0.52)*3.7);
    return max(0.0, fallbackCubemapMipmaps - 16 +  pow(roughness, 0.25) * 15.0);

    // return fallbackCubemapMipmaps - roughness * 11.0;
}

vec3 filterEnvironmentMap(samplerCube tex, Material material, vec3 direction) {

    float mipmap = computeMipmapFromRoughness(material.roughness);
    float mipSize = pow(2.0, fallbackCubemapMipmaps - mipmap);
    float antialiasingFactor = saturate(length(dFdx(direction)) + length(dFdy(direction)));
    mipmap += antialiasingFactor * CUBEMAP_ANTIALIASING_FACTOR;

    return textureLod(tex, direction, mipmap).xyz;
}



vec3 computeAmbient(Material material, vec4 giAmbient, vec4 giSpecular, float occlusionFactor, vec3 v) {

    #if defined(DEBUG_DISABLE_AMBIENT) || defined(DEBUG_RM_PSSM_SPLITS) || defined(DEBUG_RM_SHADOWS)
        return vec3(0.0);
    #endif


    #if defined(DEBUG_RM_GI_AMBIENT)
        return giAmbient.xyz;
    #endif

    float NxV = max(0.0, dot(material.normal, v));
    float borderFactor = saturate( pow(saturate(1.0 - NxV), 5.0));
    // borderFactor = 1.0;

    #if defined(USE_SCATTERING) && !defined(DISABLE_ATTENUATION_READ)
    vec3 attenuation = texelFetch(scatteringAttenuation, ivec2(gl_FragCoord.xy), 0).xyz;

    #else
    vec3 attenuation = vec3(1);
    #endif

    // return attenuation;

    vec3 reflectedDir = (reflect( -v, material.normal ));
    vec3 ambientRefColor = filterEnvironmentMap(fallbackCubemap, material, transformCubemapCoordinates(reflectedDir));


    vec3 iblColor = textureLod(fallbackCubemap, transformCubemapCoordinates(material.normal), fallbackCubemapMipmaps - 4).xyz;
    iblColor = pow(iblColor, vec3(1.5)) * 3.0;

    // return iblColor;

    #if defined(USE_SCATTERING)

    vec3 scatteringReflected = textureLod(scatteringCubemap, reflectedDir, 0).xyz;
    vec3 scatteringAmbient = textureLod(scatteringCubemap, material.normal, 0).xyz;
    #else
    vec3 scatteringReflected = ambientRefColor;
    vec3 scatteringAmbient = vec3(1);
    #endif


    // return scatteringAmbient;

    // return giAmbient.xyz;

    vec3 result = vec3(0);

    occlusionFactor = pow(occlusionFactor, 2.0);
    // occlusionFactor = pow(saturate(occlusionFactor - 0.4), 1.5) * 3.0;
    // occlusionFactor = 1.0;
    // giAmbient.xyz = vec3(1);

    #if defined(USE_GLOBAL_ILLUMINATION)
        // occlusionFactor = 0.5 + giAmbient.w * 0.5;
    #endif


    vec3 environmentColor = scatteringReflected * 1.5;
    // environmentColor = ambientRefColor * 1.5;
    environmentColor = pow(environmentColor, vec3(1.0 / 2.2));
    environmentColor *= pow(ambientRefColor, vec3(1.0 / 1.0));

    // environmentColor = scatteringReflected;

    // environmentColor = ambientRefColor;

    // ambientRefColor = pow(ambientRefColor, vec3(0.2)) * 0.7;
    // ambientRefColor = pow(ambientRefColor, vec3(5.0));
    // return ambientRefColor;


    result += 
                giAmbient.xyz *                             // Global Illumination 
                occlusionFactor *                           // Ambient Occlusion
                material.baseColor *                        // Tint by material color
                saturate(1.0 - material.metallic) *         // No diffuse ambient for metallic objects
                saturate(1.0 + giAmbient.w) *               // Global Illumination Occlusion
                0.2 * vec3(1.0,1.1,1.2)                    // Color tint
                *mix(iblColor*0.5, vec3(0.5), 1.0) * 
                mix(scatteringAmbient*1.0, vec3(1), 1.0)
    ;


    // result += borderFactor * environmentColor * 0.1 * saturate(1.0 - 0*material.metallic) * material.specular * pow(iblColor, vec3(1.0));

    // return vec3(giSpecular.w);
    environmentColor = mix(environmentColor, giSpecular.xyz, giSpecular.w );


    vec3 metallicSpecularAmbient = mix(environmentColor, material.baseColor, material.translucency) * mix(occlusionFactor, 1.0, 0.0) * material.specular;
    // metallicSpecularAmbient = ambientRefColor * material.specular * 0.5;

    // Make metallic materials brighter at the border

    result += metallicSpecularAmbient * material.metallic;

    // Take ambient factor into account
    result *= GLOBAL_AMBIENT_FACTOR;

    // result *= (0.01 + pow(attenuation, vec3(1.0 / 2.2)));



    // result = ambientRefColor;


    return result;
}