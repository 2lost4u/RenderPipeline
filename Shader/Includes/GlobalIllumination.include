#pragma once

#pragma optionNV (unroll all)

#pragma include "Includes/Configuration.include"
#pragma include "Includes/Structures/Material.struct"
#pragma include "Includes/PoissonDisk.include"
#pragma include "Includes/Structures/GIData.struct"

uniform GIData giData;
uniform float giReadyState;
uniform sampler3D giVoxelData0;
uniform sampler3D giVoxelData1;
uniform sampler3D giVoxelData2;
uniform sampler3D giVoxelData3;
uniform sampler3D giVoxelData4;

struct Voxel {
    vec3 posX;
    vec3 negX;
    vec3 posY;
    vec3 negY;
    vec3 posZ;
    vec3 negZ;
    float solid;
};


uniform int frameIndex;

Voxel fetchVoxel(vec3 coord, float lod) {
    vec4 sample0 = textureLod(giVoxelData0, coord, lod);
    vec4 sample1 = textureLod(giVoxelData1, coord, lod);
    vec4 sample2 = textureLod(giVoxelData2, coord, lod);
    vec4 sample3 = textureLod(giVoxelData3, coord, lod);
    vec4 sample4 = textureLod(giVoxelData4, coord, lod);


    Voxel v;
    v.posX = vec3(sample0.x, sample0.y, sample0.z);
    v.negX = vec3(sample1.x, sample1.y, sample1.z);
    v.posY = vec3(sample2.x, sample2.y, sample2.z);
    v.negY = vec3(sample3.x, sample3.y, sample3.z);
    v.posZ = vec3(sample4.x, sample4.y, sample4.z);

    v.negZ = vec3(sample0.w, sample1.w, sample2.w);
    v.solid = sample4.w;
    return v;
}

vec4 computeGlobalIllumination(Material m, vec3 viewVector, GIData data, out vec4 specularColor, vec3 flatNormal, vec3 cameraPosition) {


    // In case the gi is still building
    if (giReadyState < 0.5) {
        return vec4(0.4);
    }

    // The color which is returned when a pixel is not in the gi range.
    // Also used to fade out gi at the grid borders.
    float boundsColor = 1.0;

    // Fetch the normal used to compute the cone directions
    // vec3 correctNormal = normalize(cross(dFdx(m.position), dFdy(m.position)));
    // vec3 correctNormal = m.normal;

    // Compute grid variables
    vec3 gridStart = data.position - data.size*0.9;
    vec3 gridEnd = data.position + data.size*0.9;
    float voxelSize = (2.0 * data.size) / data.resolution;

    // Check if the pixel is in the grid
    bool isInGrid = all(greaterThan(m.position, gridStart)) && 
                    all(lessThan(m.position, gridEnd));

    specularColor = vec4(0);

    // If not in gi range, ignore this pixel
    // TODO: Check if early out is actually faster
    if (!isInGrid) return vec4(0.4);

    // Bias position a bit, so self shadowing gets less strong
    vec3 biasedPosition = m.position + m.normal * voxelSize * 1.0;

    // Compute coordinate in voxel space
    vec3 localCoord = (biasedPosition-data.position + data.size) / (2 * data.size);
    vec3 localCoordOffs = mod(localCoord, 1.0 / data.resolution);
    ivec3 localCoordInGrid = ivec3(localCoord * data.resolution);
    specularColor = vec4(0.2, 0.6, 1.0, 0);

    Voxel v = fetchVoxel(localCoord, 0);
    vec3 resultSum = vec3(0);


    resultSum += saturate(1.0 + (-m.normal.x)) * v.posX;
    resultSum += saturate(1.0 + (m.normal.x)) * v.negX;
    resultSum += saturate(1.0 + (-m.normal.y)) * v.posY;
    resultSum += saturate(1.0 + (m.normal.y)) * v.negY;
    resultSum += saturate(1.0 + (-m.normal.z)) * v.posZ;
    resultSum += saturate(1.0 + (m.normal.z)) * v.negZ;

    // resultSum = v.posX + v.negX + v.posY + v.negY + v.posZ + v.negZ;
    // resultSum = v.posZ * 3.0;
    // resultSum *= 0.01;
    resultSum *= 0.3;

    // resultSum += 1.5;
    // resultSum += 0.02;

    return vec4(resultSum, 1);

}
