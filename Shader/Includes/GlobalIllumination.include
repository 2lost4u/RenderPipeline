#pragma once

#pragma optionNV (unroll all)

#pragma include "Includes/Configuration.include"
#pragma include "Includes/Structures/Material.struct"
#pragma include "Includes/PoissonDisk.include"
#pragma include "Includes/Structures/GIData.struct"

uniform GIData giData;
uniform float giReadyState;
uniform sampler3D giVoxelData0;
uniform sampler3D giVoxelData1;
uniform sampler3D giVoxelData2;
uniform sampler3D giVoxelData3;
uniform sampler3D giVoxelData4;

struct Voxel {
    vec3 posX;
    vec3 negX;
    vec3 posY;
    vec3 negY;
    vec3 posZ;
    vec3 negZ;
    float solid;
};


uniform int frameIndex;

Voxel fetchVoxel(vec3 coord, float lod) {
    vec4 sample0 = textureLod(giVoxelData0, coord, lod);
    vec4 sample1 = textureLod(giVoxelData1, coord, lod);
    vec4 sample2 = textureLod(giVoxelData2, coord, lod);
    vec4 sample3 = textureLod(giVoxelData3, coord, lod);
    vec4 sample4 = textureLod(giVoxelData4, coord, lod);


    Voxel v;
    v.posX = vec3(sample0.x, sample0.y, sample0.z);
    v.negX = vec3(sample1.x, sample1.y, sample1.z);
    v.posY = vec3(sample2.x, sample2.y, sample2.z);
    v.negY = vec3(sample3.x, sample3.y, sample3.z);
    v.posZ = vec3(sample4.x, sample4.y, sample4.z);

    v.negZ = vec3(sample0.w, sample1.w, sample2.w);
    v.solid = sample4.w;
    return v;
}

vec4 computeGlobalIllumination(vec3 pos, vec3 normal, vec3 viewVector, out vec4 specularColor) {

    vec4 offColor = vec4(vec3(1.5), 1.0);

    // In case the gi is still building
    if (giReadyState < 0.5) {
        return offColor;
    }

    // Compute grid variables
    vec3 gridStart = giData.position - giData.size*0.9;
    vec3 gridEnd = giData.position + giData.size*0.9;
    float voxelSize = (2.0 * giData.size) / giData.resolution;

    // Check if the pixel is in the grid
    bool isInGrid = all(greaterThan(pos, gridStart)) && 
                    all(lessThan(pos, gridEnd));

    specularColor = vec4(0);

    // If not in gi range, ignore this pixel
    // TODO: Check if early out is actually faster
    if (!isInGrid) return offColor;



    // Bias position a bit, so self shadowing gets less strong
    vec3 biasedPosition = pos + normal * voxelSize * 1.0;
    vec3 biasedReflPosition = pos + normal * voxelSize * 1.1;

    // Compute coordinate in voxel space
    vec3 localCoord = (biasedPosition-giData.position + giData.size) / (2 * giData.size);
    vec3 localReflCoord = (biasedReflPosition-giData.position + giData.size) / (2 * giData.size);
    vec3 localCoordOffs = mod(localCoord+ 0.5/giData.resolution, 1.0 / giData.resolution) * giData.resolution;


    // Compute fade factor
    float fade = 1;
    float fadeArea = 0.1;
    fade *= saturate(localCoord.x / fadeArea);
    fade *= saturate( (1.0 - localCoord.x) / fadeArea);
    fade *= saturate(localCoord.y / fadeArea);
    fade *= saturate( (1.0 - localCoord.y) / fadeArea);
    fade *= saturate(localCoord.z / fadeArea);
    fade *= saturate( (1.0 - localCoord.z) / fadeArea);



    ivec3 localCoordInGrid = ivec3(localCoord * giData.resolution);
    specularColor = vec4(0);

    Voxel v = fetchVoxel(localCoord, 0);
    vec3 resultSum = vec3(0);

    #if 0
    float mixFactor = 1.0;

    resultSum += saturate(1.0 + mixFactor * (-normal.x)) * v.posX;
    resultSum += saturate(1.0 + mixFactor * (normal.x)) * v.negX;
    resultSum += saturate(1.0 + mixFactor * (-normal.y)) * v.posY;
    resultSum += saturate(1.0 + mixFactor * (normal.y)) * v.negY;
    resultSum += saturate(1.0 + mixFactor * (-normal.z)) * v.posZ;
    resultSum += saturate(1.0 + mixFactor * (normal.z)) * v.negZ;

    #else
    float amb = 0.2;
    float fact = 1.0;
    resultSum += saturate(amb + fact*saturate(-normal.x)) * v.posX;
    resultSum += saturate(amb + fact*saturate(normal.x)) * v.negX;
    resultSum += saturate(amb + fact*saturate(-normal.y)) * v.posY;
    resultSum += saturate(amb + fact*saturate(normal.y)) * v.negY;
    resultSum += saturate(amb + fact*saturate(-normal.z)) * v.posZ;
    resultSum += saturate(amb + fact*saturate(normal.z)) * v.negZ;


    #endif

    // resultSum = v.posX + v.negX + v.posY + v.negY + v.posZ + v.negZ;
    // resultSum = v.posZ * 1.0;
    // resultSum *= 0.0002;

    #if GI_QUALITY_LEVEL == 0
        resultSum *= 0.5;
    #elif GI_QUALITY_LEVEL == 1
        resultSum *= 0.07;
    #elif GI_QUALITY_LEVEL == 2
        resultSum *= 0.0003;
    #endif



    resultSum *= 2.0;
    // resultSum = resultSum.yyy;

    // SRGB
    resultSum += vec3(0.017, 0.019, 0.02) * 0.01;
    resultSum = pow(resultSum, vec3(1.0 / 2.2));


    // if (any(lessThan(localCoordOffs, vec3(0.05) ))) {
    //     resultSum = mix(resultSum, vec3(1, 0, 0), 0.05);
    // }


    // Trace specular
    #if 0
    const int numSpecularSteps = 16;
    vec3 startCoord = localReflCoord;
    vec3 reflectedVec = reflect(-viewVector, normal);
    vec3 endCoord = startCoord + normalize(reflectedVec) * 0.4;
    vec3 coordStep = (endCoord - startCoord) / float(numSpecularSteps);
    vec3 specularIntersection = vec3(0);
    float accum = 0.0;

    for (int i = 0; i < numSpecularSteps; i++) {

        float solidness = step(0.5, textureLod(giVoxelData4, startCoord, 0).w);
        float impact = solidness * saturate(1.0 - accum);
        specularIntersection += impact * startCoord;
        accum += impact;
        startCoord += coordStep;
        // coordStep *= 1.1;
    }

    if (specularIntersection.x >= 0.01) {
        specularIntersection -= reflectedVec / giData.resolution * 0.5;
        Voxel refV = fetchVoxel(specularIntersection, 0);
        vec3 reflColor = (refV.posX+refV.negX + refV.posY+ refV.negY +refV.posZ+refV.negZ) * 0.001;
        reflColor += vec3(0.017, 0.019, 0.02) * 1.0;
        specularColor.xyz = pow(reflColor, vec3(1.0 / 1.6));
        specularColor.w = 1.0;
    }

    #endif
    


    return vec4(mix(offColor.xyz, resultSum, fade), 1);

}
