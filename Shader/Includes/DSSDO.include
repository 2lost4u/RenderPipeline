


#include "Includes/Configuration.include"
#include "Includes/PoissonDisk.include"
#include "Includes/Random.include"
#include "Includes/Material.include"

const int dssdoSampleCount = DSSDO_NUM_SAMPLES;
const float fudgeFactorL0 = 2.0;
const float fudgeFactorL1 = 10.0;
const float dssdoRadius = 35.0;
const float dssdoMaxDistance = 7.0;
const float dssdoMaxAngle = 0.1;
const float dssdoFactor = 0.7;

const float sh2WeightL0 = fudgeFactorL0 * 0.28209; //0.5*sqrt(1.0/pi);
const vec3 sh2WeightL1 = vec3(fudgeFactorL1 * 0.48860); //0.5*sqrt(3.0/pi);
const vec4 sh2Weight = vec4(sh2WeightL1, sh2WeightL0) / dssdoSampleCount;


uniform sampler2D dssdoNoiseTex;

float computeDSSDO(vec2 texcoord, ivec2 screenCoord, Material material, sampler2D normalTex, sampler2D positionTex) {

    ivec2 noiseSize = textureSize(dssdoNoiseTex, 0);
    ivec2 screenSize = textureSize(normalTex, 0);
    vec3 noise = texelFetch(dssdoNoiseTex, screenCoord % noiseSize, 0 ).rgb*1.0 - 0.5;
    float occlusionResult = 0.0;

    for (int i = 0; i < dssdoSampleCount; i++) {
        vec3 offset = poisson3D_32[i];
        ivec2 offsetCoord = clamp(screenCoord + ivec2(reflect(offset, noise).xy * dssdoRadius), ivec2(0), screenSize-1);
        vec3 position = texelFetch(positionTex, offsetCoord, 0).rgb;
        vec3 difference = (position - material.position);
        float differenceLength = length(difference);
        vec3 differenceNormalized = difference / differenceLength;
        float attenuation = 1.0 - (max(0.0, min(1.0, differenceLength / dssdoMaxDistance)));
        float dotProduct = dot(material.normal, differenceNormalized);
        attenuation = attenuation*attenuation * step(dssdoMaxAngle, dotProduct);
        occlusionResult += attenuation * sh2Weight * 0.5;
    }

    occlusionResult = 1.0 - occlusionResult;
    occlusionResult = mix(1.0, occlusionResult, dssdoFactor);


    return saturate(occlusionResult);
}