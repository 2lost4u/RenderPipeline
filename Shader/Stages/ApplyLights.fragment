#version 400

#pragma include "Includes/Configuration.include"
#pragma include "Includes/LightCulling.include"
#pragma include "Includes/PositionReconstruction.include"
#pragma include "Includes/Lights.include"

in vec2 texcoord;
out vec4 result;

uniform sampler2D GBufferDepth;
uniform isampler2DArray CellIndices;
uniform isamplerBuffer PerCellLights;

uniform samplerBuffer AllLightsData;



void main() {
    ivec2 coord = ivec2(gl_FragCoord.xy);
    float depth = texelFetch(GBufferDepth, coord, 0).x;
    ivec3 tile = getCellIndex(coord, depth);

    vec3 worldPos = calculateSurfacePos(depth, texcoord);

    if (tile.z >= LC_TILE_SLICES) {
        result = vec4(1, 0.5, 0, 1);
        return;
    }

    int cellIndex = texelFetch(CellIndices, tile, 0).x;
    int dataOffs = cellIndex * (MAX_LIGHTS_PER_CELL+1);
    int numLights = min(MAX_LIGHTS_PER_CELL, texelFetch(PerCellLights, dataOffs).x);

    vec3 shadingResult = vec3(0);

    for (int i = 0; i < numLights; i++) {
        int lightOffs = i * 4;
        vec4 data0 = texelFetch(AllLightsData, lightOffs + 0);
        vec4 data1 = texelFetch(AllLightsData, lightOffs + 1);
        vec4 data2 = texelFetch(AllLightsData, lightOffs + 2);
        vec4 data3 = texelFetch(AllLightsData, lightOffs + 3);

        int lightType = int(data0.x);
        vec3 lightPos = data0.yzw;
        vec3 lightColor = data1.xyz;

        float attenuation = 0;
        vec3 l = vec3(0);

        if (lightType == LT_POINT_LIGHT) {

            float radius = data1.w;
            float innerRadius = data2.x;


            // attenuation = computePointLightAttenuation(radius, distance(worldPos, lightPos));
            attenuation = step(distance(worldPos, lightPos), radius);
            // shadingResult += 0.1;
            shadingResult += attenuation;
        }


        // shadingResult += lightColor * attenuation;

    }

    result = vec4(shadingResult, 1);


    result.w = 1.0;
}